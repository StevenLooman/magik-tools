#!/usr/bin/env python3

# Generate the AstWalker class from the MagikGrammar.
# Running:
#   $ pwd
#   .../magik-tools/magik-squid/src/main/java/nl/ramsolutions/sw/magik/analysis
#   $ cat ../api/MagikGrammar.java | ./generate_ast_walker.py >! AstWalker.java

import fileinput
import re

IGNORE_ELEMENTS = ['WHITESPACE', 'SPACING', 'SPACING_NO_LB', 'NEXT_NOT_LB', 'EOS']

elements = [
  line[4:-2]
  for line in fileinput.input()
  if re.match(r"[ ]{4}[A-Z_]+", line) and \
     line[4:-2] not in IGNORE_ELEMENTS
]

def to_java_name(element):
  return ''.join(el.title() for el in element.split("_"))


# generate preamble
print("""package nl.ramsolutions.sw.magik.analysis;

import com.sonar.sslr.api.AstNode;
import com.sonar.sslr.api.AstNodeType;
import com.sonar.sslr.api.Token;
import com.sonar.sslr.api.Trivia;
import nl.ramsolutions.sw.magik.api.MagikGrammar;

/**
 * A {@link AstNode} tree walker with pre- and post-methods to iterate a parse tree.
 * Note that this is generated by the {@code generate_ast_walker.py} script,
 * do not edit this file manually!
 */
public abstract class AstWalker {

    /**
     * Walk children of node.
     */
    protected void walkChildren(final AstNode node) {
        for (final AstNode childNode : node.getChildren()) {
            this.walkAst(childNode);
        }
    }

    /**
     * Walk trivia and tokens of node.
     */
    protected void walkTokens(final AstNode tokenNode) {
        // Assume there can be only one token.
        final Token token = tokenNode.getToken();
        token.getTrivia().forEach(this::walkTrivia);
        this.walkToken(token);
    }

    /**
     * Start walking the node. The pre- and post-methods are called upon tree traversal.
     * @param node Node to start walking.
     */
    @SuppressWarnings({"java:S1479", "checkstyle:MethodLength"})
    public void walkAst(final AstNode node) {
        final AstNodeType nodeType = node.getType();
        if (!(nodeType instanceof MagikGrammar)) {
            this.walkTokens(node);
            return;
        }

        final MagikGrammar value = (MagikGrammar) nodeType;
        switch (value) {""")

# generate cases
for element in elements:
  java_name = to_java_name(element)
  print(f"""
            case {element}:
                this.walkPre{java_name}(node);
                this.walkChildren(node);
                this.walkPost{java_name}(node);
                break;""")

print("""
            default:
                this.walkPreDefault(node);
                this.walkChildren(node);
                this.walkPostDefault(node);
                break;
        }
    }""")

# generate pre- and post-walk-methods
for element in elements:
  java_name = to_java_name(element)
  print(f"""
    protected void walkPre{java_name}(final AstNode node) {{
        this.walkPreDefault(node);
    }}

    protected void walkPost{java_name}(final AstNode node) {{
        this.walkPostDefault(node);
    }}""")

print("""
    protected void walkPreDefault(final AstNode node) {
        // pass
    }

    protected void walkPostDefault(final AstNode node) {
        // pass
    }

    protected void walkToken(final Token token) {
        // pass
    }

    protected void walkTrivia(final Trivia trivia) {
        // pass
    }

}""")
